% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/day23.R
\name{create_coprocessor}
\alias{create_coprocessor}
\title{Day 23: Coprocessor Conflagration}
\usage{
create_coprocessor(commands)
}
\description{
\href{http://adventofcode.com/2017/day/23}{Coprocessor Conflagration}
}
\details{
\strong{Part One}

You decide to head directly to the CPU and fix the printer from there.
As you get close, you find an \emph{experimental coprocessor} doing so much
work that the local programs are afraid it will \href{https://en.wikipedia.org/wiki/Halt_and_Catch_Fire}{halt and catch fire}. This would
cause serious issues for the rest of the computer, so you head in and
see what you can do.

The code it's running seems to be a variant of the kind you saw recently
on that \href{http://adventofcode.com/2017/day/18}{tablet}. The general
functionality seems \emph{very similar}, but some of the instructions are
different:
\itemize{
\item \code{set X Y} \emph{sets} register \code{X} to the value of \code{Y}.
\item \code{sub X Y} \emph{decreases} register \code{X} by the value of \code{Y}.
\item \code{mul X Y} sets register \code{X} to the result of \emph{multiplying} the value
contained in register \code{X} by the value of \code{Y}.
\item \code{jnz X Y} \emph{jumps} with an offset of the value of \code{Y}, but only if
the value of \code{X} is \emph{not zero}. (An offset of \code{2} skips the next
instruction, an offset of \code{-1} jumps to the previous instruction,
and so on.)
}

The coprocessor is currently set to some kind of \emph{debug mode}, which
allows for testing, but prevents it from doing any meaningful work.

If you run the program (your puzzle input), \emph{how many times is the \code{mul}
instruction invoked?}

\strong{Part Two}

Now, it's time to fix the problem.

The \emph{debug mode switch} is wired directly to register \code{a}. You flip the
switch, which makes \emph{register
\code{a} now start at \code{1}} when the program is executed.

Immediately, the coprocessor begins to overheat. Whoever wrote this
program obviously didn't choose a very efficient implementation. You'll
need to \emph{optimize the program} if it has any hope of completing before
Santa needs that printer working.

The coprocessor's ultimate goal is to determine the final value left in
register \code{h} once the program completes. Technically, if it had that...
it wouldn't even need to run the program.

After setting register \code{a} to \code{1}, if the program were to run to
completion, \emph{what value would be left in register \code{h}?}
}
